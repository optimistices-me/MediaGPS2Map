<!DOCTYPE html>
<html>
<head>
    <title>照片位置热图</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
        }

        #map {
            height: 100vh;
            width: 75%; /* 地图占 75% 宽度 */
        }

        #sidebar {
            width: 25%;
            background-color: #f4f4f4;
            padding: 20px;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* 保证内容部分不被压缩 */
            height: 100vh; /* 让侧栏充满视口 */
            overflow-y: auto; /* 让侧栏部分能够滚动 */
        }

        #controls {
            margin-top: auto; /* 使控件部分固定在侧栏底部 */
        }

        input[type="range"] {
            width: 60%; /* 拖动条宽度 */
            margin-right: 10px;
        }

        input[type="number"] {
            width: 60px; /* 输入框宽度 */
            font-size: 1em;
            padding: 2px;
        }

        input[type="color"] {
            width: 50px; /* 调色盘颜色输入框 */
            height: 30px;
        }

        label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 5px 0;
        }

        .gradient-color {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .gradient-color input[type="number"] {
            width: 50px; /* 透明度输入框 */
        }

        #controls p {
            display: flex;
            align-items: center;
        }

        #controls p input[type="range"] {
            width: 70%; /* 拖动条宽度 */
        }

        #controls p input[type="number"] {
            width: 60px; /* 输入框宽度，适合显示4个字符 */
            margin-left: 10px;
        }

        /* 时间筛选样式 */
        #time-filter {
            margin: 20px 0;
        }
        #timeline-container {
            position: relative;
            height: 40px;
            margin: 20px 0;
        }
        #timeline {
            width: 100%;
            height: 5px;
            background: #ddd;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
        }
        #timeline-handle-start,
        #timeline-handle-end {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #007bff;
            border-radius: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
        }
        #timeline-handle-start { left: 0; }
        #timeline-handle-end { left: 100%; }
        .time-input {
            display: flex;
            gap: 10px;
            margin-top: 30px;
        }
        .time-input input {
            width: 45%;
            padding: 5px;
        }

    </style>
</head>
<body>
    <div id="map"></div>
    <div id="sidebar">
        <div>
            <h2>统计信息</h2>
            <p>文件数量: <span id="file-count">0</span></p>
            <p>时间范围: <span id="time-range">无</span></p>
            <p>典型位置:</p>
            <ul id="sample-locations"></ul>
        </div>

        <div id="time-filter">
            <h3>时间范围筛选</h3>
            <div id="timeline-container">
                <div id="timeline"></div>
                <div id="timeline-handle-start"></div>
                <div id="timeline-handle-end"></div>
            </div>
            <div class="time-input">
                <input type="datetime-local" id="start-time" />
                <input type="datetime-local" id="end-time" />
            </div>
            <button class="reset-button" id="reset-time">重置起止时间</button>
        </div>

        <div id="controls">
            <p>Radius:
                <input type="range" id="radius" min="1" max="50" value="4" />
                <input type="number" id="radius-value" value="4" />
            </p>

            <p>Blur:
                <input type="range" id="blur" min="0" max="10" value="2" />
                <input type="number" id="blur-value" value="2" />
            </p>

            <p>Min Opacity:
                <input type="range" id="minOpacity" min="0" max="1" step="0.01" value="0.4" />
                <input type="number" id="minOpacity-value" value="0.4" step="0.01" />
            </p>

            <p>Gradient:
                <div class="gradient-color">
                    <label>Low Color:
                        <input type="color" id="lowColor" value="#0000ff" />
                        <input type="number" id="lowOpacity" value="0.9" min="0" max="1" step="0.01" />
                    </label>
                </div>

                <div class="gradient-color">
                    <label>Mid Color:
                        <input type="color" id="midColor" value="#ffff00" />
                        <input type="number" id="midOpacity" value="0.6" min="0" max="1" step="0.01" />
                    </label>
                </div>

                <div class="gradient-color">
                    <label>High Color:
                        <input type="color" id="highColor" value="#ff0000" />
                        <input type="number" id="highOpacity" value="0.2" min="0" max="1" step="0.01" />
                    </label>
                </div>
            </p>
        </div>

    <!-- Leaflet 核心库 -->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <!-- Leaflet.heat 插件 -->
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>

    <script>
        let currentPoints = [];
        let heatmapLayer = null;
        const map = L.map('map').setView([30, 120], 3);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

        let currentHeatmapParams = {
            radius: 4,
            blur: 2,
            minOpacity: 0.4,
            gradient: {
                0.1: 'rgba(0, 0, 255, 0.9)',
                0.5: 'rgba(255, 255, 0, 0.6)',
                1.0: 'rgba(255, 0, 0, 0.2)'
            }
        };

        // 初始化时间范围
        let startTime = null;
        let endTime = null;
        let isDragging = false;
        let currentHandle = null;
        const timelineContainer = document.getElementById('timeline-container');
        const timeline = document.getElementById('timeline');
        const handleStart = document.getElementById('timeline-handle-start');
        const handleEnd = document.getElementById('timeline-handle-end');

        // 初始化时间范围
        let initialStartTime = null;
        let initialEndTime = null;

        function initTimeRange() {
            const timestamps = currentPoints.map(p => new Date(p.timestamp).getTime());
            // 使用循环计算最小和最大时间戳，避免使用扩展运算符
            let minTimestamp = Infinity;
            let maxTimestamp = -Infinity;
            for (let t of timestamps) {
                if (t < minTimestamp) minTimestamp = t;
                if (t > maxTimestamp) maxTimestamp = t;
            }

            // 设置时间范围的最小值和最大值
            document.getElementById('start-time').min = new Date(minTimestamp).toISOString().slice(0,16);
            document.getElementById('start-time').max = new Date(maxTimestamp).toISOString().slice(0,16);
            document.getElementById('end-time').min = new Date(minTimestamp).toISOString().slice(0,16);
            document.getElementById('end-time').max = new Date(maxTimestamp).toISOString().slice(0,16);

            // 保存初始时间区间
            initialStartTime = minTimestamp;
            initialEndTime = maxTimestamp;

            // 默认值设置为最小时间和最大时间
            document.getElementById('start-time').value = new Date(minTimestamp).toISOString().slice(0,16);
            document.getElementById('end-time').value = new Date(maxTimestamp).toISOString().slice(0,16);

            startTime = minTimestamp;
            endTime = maxTimestamp;

            // 设置时间轴的范围
            const timelineWidth = timeline.offsetWidth;
            const startPercent = (minTimestamp - minTimestamp) / (maxTimestamp - minTimestamp) * 100;
            const endPercent = (maxTimestamp - minTimestamp) / (maxTimestamp - minTimestamp) * 100;
            handleStart.style.left = `${startPercent}%`;
            handleEnd.style.left = `${endPercent}%`;
        }

        // 重置时间按钮功能
        document.getElementById('reset-time').addEventListener('click', () => {
            // 重置时间输入框到初始值
            document.getElementById('start-time').value = new Date(initialStartTime).toISOString().slice(0,16);
            document.getElementById('end-time').value = new Date(initialEndTime).toISOString().slice(0,16);

            // 重置时间条端点回初始值
            const startPercent = (initialStartTime - initialStartTime) / (initialEndTime - initialStartTime) * 100;
            const endPercent = (initialEndTime - initialStartTime) / (initialEndTime - initialStartTime) * 100;
            handleStart.style.left = `${startPercent}%`;
            handleEnd.style.left = `${endPercent}%`;

            // 更新全局时间
            startTime = initialStartTime;
            endTime = initialEndTime;

            updateTimeRange(); // 更新数据
        });

        // 更新侧栏信息
        let updateSidebarTimeout = null;
        function updateSidebar(data) {
            if (updateSidebarTimeout) {
                clearTimeout(updateSidebarTimeout);
            }

            updateSidebarTimeout = setTimeout(() => {
                const fileCount = data.points.length;
                // 将所有时间戳提取出来
                const timestamps = data.points.map(p => new Date(p.timestamp).getTime());

                // 使用循环计算最小和最大时间戳，避免使用扩展运算符
                let minTimestamp = Infinity;
                let maxTimestamp = -Infinity;
                for (let t of timestamps) {
                    if (t < minTimestamp) minTimestamp = t;
                    if (t > maxTimestamp) maxTimestamp = t;
                }
                const minTime = new Date(minTimestamp).toLocaleString();
                const maxTime = new Date(maxTimestamp).toLocaleString();

                document.getElementById('file-count').textContent = fileCount;
                document.getElementById('time-range').textContent = `${minTime} - ${maxTime}`;

                // 显示典型位置
                const sampleLocations = document.getElementById('sample-locations');
                sampleLocations.innerHTML = data.addresses.map(addr => `<li>${addr}</li>`).join('');
            }, 300);  // 延迟 300ms 后执行
        }

        // 拖动事件处理
        timelineContainer.addEventListener('mousedown', (e) => {
            isDragging = true;
            const rect = timeline.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const percent = clickX / rect.width;

            if (Math.abs(percent * 100 - parseFloat(handleStart.style.left)) < 10) {
                currentHandle = handleStart;
            } else if (Math.abs(percent * 100 - parseFloat(handleEnd.style.left)) < 10) {
                currentHandle = handleEnd;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging && currentHandle) {
                const rect = timeline.getBoundingClientRect();
                const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                const percent = (x / rect.width) * 100;

                currentHandle.style.left = `${percent}%`;
                const currentTime = startTime + (percent / 100) * (endTime - startTime);

                if (currentHandle === handleStart) {
                    const newStartTime = new Date(currentTime);
                    document.getElementById('start-time').value = newStartTime.toISOString().slice(0, 16);
                } else {
                    const newEndTime = new Date(currentTime);
                    document.getElementById('end-time').value = newEndTime.toISOString().slice(0, 16);
                }
            }
        });


        document.addEventListener('mouseup', () => {
            isDragging = false;
            currentHandle = null;
            updateTimeRange();
        });

        // 输入框变化监听
        document.getElementById('start-time').addEventListener('change', updateTimeRange);
        document.getElementById('end-time').addEventListener('change', updateTimeRange);

        // 更新时间处理函数
        function updateTimeRange() {
            const bounds = map.getBounds();
            const start = document.getElementById('start-time').value;
            const end = document.getElementById('end-time').value;

            const params = new URLSearchParams({
                bounds: `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`,
                start: start ? new Date(start).toISOString() : '',
                end: end ? new Date(end).toISOString() : ''
            });

            fetch(`/data?${params}`)
                .then(response => response.json())
                .then(data => {
                    currentPoints = data.points;
                    updateHeatmapWithCurrentParams(); // 使用当前参数更新热图
                    updateSidebar(data);
                });
        }

        // 聚合数据函数
        function aggregatePoints(points, gridSize) {
            const aggregated = {};
            points.forEach(point => {
                const latKey = Math.floor(point.lat / gridSize) * gridSize;
                const lngKey = Math.floor(point.lng / gridSize) * gridSize;
                const key = `${latKey},${lngKey}`;

                if (!aggregated[key]) {
                    aggregated[key] = { lat: point.lat, lng: point.lng, count: 0 };
                }
                aggregated[key].count++;
            });
            return Object.values(aggregated); // 返回聚合后的数据
        }

        // 获取当前地图区域的数据
        function loadDataForBounds(bounds, updateTimeRange = true) {
            const params = new URLSearchParams({
                bounds: `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`,
                start: document.getElementById('start-time').value,
                end: document.getElementById('end-time').value
            });

            fetch(`/data?${params}`)
                .then(response => response.json())
                .then(data => {
                    currentPoints = data.points;
                    if (updateTimeRange) {
                        initTimeRange(); // 初始化时间范围，只有在数据加载后触发
                    }
                    updateHeatmapWithCurrentParams(); // 使用当前参数更新热图
                    updateSidebar(data);
                });
        }

        function updateHeatmapWithCurrentParams() {
            if (heatmapLayer) {
                map.removeLayer(heatmapLayer);
            }

            const points = currentPoints.map(p => [p.lat, p.lng, 1]);
            heatmapLayer = L.heatLayer(points, {
                radius: currentHeatmapParams.radius,
                blur: currentHeatmapParams.blur,
                minOpacity: currentHeatmapParams.minOpacity,
                gradient: currentHeatmapParams.gradient
            }).addTo(map);
        }

        let debounceTimeout = null;

        // 监听地图移动事件
        map.on('moveend', function () {
            if (debounceTimeout) {
                clearTimeout(debounceTimeout);
            }

            debounceTimeout = setTimeout(() => {
                const bounds = map.getBounds();
                // 确保缩放时不会触发时间范围的更新
                loadDataForBounds(bounds, false);  // 传递一个标志位，避免时间范围更新
            }, 200); // 延迟 200 毫秒触发
        });

        // 初始化加载数据
        const initialBounds = map.getBounds();
        loadDataForBounds(initialBounds);

        // 添加坐标转换函数
        function wgs84ToGcj02(lat, lng) {
            const a = 6378245.0;
            const ee = 0.00669342162296594323;

            function transformLat(x, y) {
                let ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
                ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0;
                ret += (20.0 * Math.sin(y * Math.PI) + 40.0 * Math.sin(y / 3.0 * Math.PI)) * 2.0 / 3.0;
                ret += (160.0 * Math.sin(y / 12.0 * Math.PI) + 320 * Math.sin(y * Math.PI / 30.0)) * 2.0 / 3.0;
                return ret;
            }

            function transformLng(x, y) {
                let ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
                ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0;
                ret += (20.0 * Math.sin(x * Math.PI) + 40.0 * Math.sin(x / 3.0 * Math.PI)) * 2.0 / 3.0;
                ret += (150.0 * Math.sin(x / 12.0 * Math.PI) + 300.0 * Math.sin(x / 30.0 * Math.PI)) * 2.0 / 3.0;
                return ret;
            }

            const dLat = transformLat(lng - 105.0, lat - 35.0);
            const dLng = transformLng(lng - 105.0, lat - 35.0);
            const radLat = lat / 180.0 * Math.PI;
            const magic = Math.sin(radLat);
            const sqrtMagic = Math.sqrt(1 - ee * magic * magic);
            const dLatFinal = (dLat * 180.0) / ((a * (1 - ee)) / (sqrtMagic ** 3) * Math.PI);
            const dLngFinal = (dLng * 180.0) / (a / sqrtMagic * Math.cos(radLat) * Math.PI);
            return [lat + dLatFinal, lng + dLngFinal];
        }

        // 热图参数控制控件
        // 监听拖动条的变化
        document.getElementById('radius').addEventListener('input', updateHeatmap);
        document.getElementById('blur').addEventListener('input', updateHeatmap);
        document.getElementById('minOpacity').addEventListener('input', updateHeatmap);

        // 监听输入框的变化
        document.getElementById('radius-value').addEventListener('input', updateHeatmapFromInput);
        document.getElementById('blur-value').addEventListener('input', updateHeatmapFromInput);
        document.getElementById('minOpacity-value').addEventListener('input', updateHeatmapFromInput);

        // 监听颜色和透明度的变化
        document.getElementById('lowColor').addEventListener('input', updateHeatmap);
        document.getElementById('midColor').addEventListener('input', updateHeatmap);
        document.getElementById('highColor').addEventListener('input', updateHeatmap);
        document.getElementById('lowOpacity').addEventListener('input', updateHeatmap);
        document.getElementById('midOpacity').addEventListener('input', updateHeatmap);
        document.getElementById('highOpacity').addEventListener('input', updateHeatmap);

        // 更新热图
        function updateHeatmap() {
            currentHeatmapParams = {
                radius: parseInt(document.getElementById('radius').value),
                blur: parseInt(document.getElementById('blur').value),
                minOpacity: parseFloat(document.getElementById('minOpacity').value),
                gradient: {
                    0.1: `rgba(${hexToRgb(document.getElementById('lowColor').value)}, ${parseFloat(document.getElementById('lowOpacity').value)})`,
                    0.5: `rgba(${hexToRgb(document.getElementById('midColor').value)}, ${parseFloat(document.getElementById('midOpacity').value)})`,
                    1.0: `rgba(${hexToRgb(document.getElementById('highColor').value)}, ${parseFloat(document.getElementById('highOpacity').value)})`
                }
            };

            updateHeatmapWithCurrentParams();
        }

        // 从输入框更新热图
        function updateHeatmapFromInput(event) {
            const id = event.target.id;
            const value = event.target.value;

            if (id === 'radius-value') {
                document.getElementById('radius').value = value;
            } else if (id === 'blur-value') {
                document.getElementById('blur').value = value;
            } else if (id === 'minOpacity-value') {
                document.getElementById('minOpacity').value = value;
            }

            updateHeatmap(); // 更新热图
        }

        // 十六进制颜色转换为RGB格式
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `${r}, ${g}, ${b}`;
        }



        // 修改点击事件处理
        map.on('click', function (e) {
            const lat = e.latlng.lat;
            const lng = e.latlng.lng;

            let closestPoint = null;
            let minDistance = Infinity;
            currentPoints.forEach(p => {
                const distance = Math.sqrt(Math.pow(p.lat - lat, 2) + Math.pow(p.lng - lng, 2));
                if (distance < minDistance) {
                    minDistance = distance;
                    closestPoint = p;
                }
            });

            if (closestPoint) {
                const [gcjLat, gcjLng] = wgs84ToGcj02(closestPoint.lat, closestPoint.lng);
                fetch(`https://restapi.amap.com/v3/geocode/regeo?key=8194eb1949ecf804aad037366e838ef1&location=${gcjLng},${gcjLat}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === '1' && data.regeocode) {
                            const address = data.regeocode.formatted_address;
                            L.popup()
                                .setLatLng([closestPoint.lat, closestPoint.lng])
                                .setContent(`
                                    <b>文件路径:</b> ${closestPoint.path}<br>
                                    <b>拍摄时间:</b> ${closestPoint.timestamp}<br>
                                    <b>地址:</b> ${address}
                                `)
                                .openOn(map);
                        }
                    })
                    .catch(error => console.error('地址请求失败:', error));
            }
        });
    </script>
</body>
</html>
