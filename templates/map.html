<!DOCTYPE html>
<html>
<head>
    <title>照片位置热力图</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
        }

        #map {
            height: 100vh;
            width: 75%; /* 地图占 75% 宽度 */
        }

        #sidebar {
            width: 25%; /* 侧栏占 25% 宽度 */
            padding: 20px;
            background-color: #f4f4f4;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="sidebar">
        <h2>统计信息</h2>
        <p>文件数量: <span id="file-count">0</span></p>
        <p>时间范围: <span id="time-range">无</span></p>
        <p>典型位置:</p>
        <ul id="sample-locations"></ul>
    </div>

    <!-- Leaflet 核心库 -->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <!-- Leaflet.heat 插件 -->
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>

    <script>
        let currentPoints = []; // 存储当前显示的点数据
        let heatmapLayer = null; // 热力图层

        // 初始化地图
        const map = L.map('map').setView([30, 120], 3);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

        // 更新侧栏信息
        let updateSidebarTimeout = null;
        function updateSidebar(data) {
            if (updateSidebarTimeout) {
                clearTimeout(updateSidebarTimeout);
            }

            updateSidebarTimeout = setTimeout(() => {
                const fileCount = data.points.length;
                // 将所有时间戳提取出来
                const timestamps = data.points.map(p => new Date(p.timestamp).getTime());

                // 使用循环计算最小和最大时间戳，避免使用扩展运算符
                let minTimestamp = Infinity;
                let maxTimestamp = -Infinity;
                for (let t of timestamps) {
                    if (t < minTimestamp) minTimestamp = t;
                    if (t > maxTimestamp) maxTimestamp = t;
                }
                const minTime = new Date(minTimestamp).toLocaleString();
                const maxTime = new Date(maxTimestamp).toLocaleString();

                document.getElementById('file-count').textContent = fileCount;
                document.getElementById('time-range').textContent = `${minTime} - ${maxTime}`;

                // 显示典型位置
                const sampleLocations = document.getElementById('sample-locations');
                sampleLocations.innerHTML = data.addresses.map(addr => `<li>${addr}</li>`).join('');
            }, 300);  // 延迟 300ms 后执行
        }

        // 聚合数据函数
        function aggregatePoints(points, gridSize) {
            const aggregated = {};
            points.forEach(point => {
                const latKey = Math.floor(point.lat / gridSize) * gridSize;
                const lngKey = Math.floor(point.lng / gridSize) * gridSize;
                const key = `${latKey},${lngKey}`;

                if (!aggregated[key]) {
                    aggregated[key] = { lat: point.lat, lng: point.lng, count: 0 };
                }
                aggregated[key].count++;
            });
            return Object.values(aggregated); // 返回聚合后的数据
        }

        // 获取当前地图区域的数据
        function loadDataForBounds(bounds) {
            const boundsStr = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
            const zoomLevel = map.getZoom();

            fetch(`/data?bounds=${boundsStr}`)
                .then(response => response.json())
                .then(data => {
                    console.log('Data received:', data);
                    currentPoints = data.points;
                    updateSidebar(data);

                    let points = [];
                    if (zoomLevel < 5) {
                        // 当缩放级别小于14时，使用聚合数据
                        console.log('Aggregating points...');
                        points = aggregatePoints(data.points, 0.1);  // 聚合大小可以根据需要调整
                        console.log('Aggregated points count:', points.length); // 查看聚合后点的数量
                    } else {
                        // 当缩放级别大于等于14时，直接使用原始数据
                        points = data.points.map(p => [p.lat, p.lng, 1]);
                    }

                    // 清除之前的热力图层
                    if (heatmapLayer) {
                        map.removeLayer(heatmapLayer);
                    }

                    // 创建新的热力图层
                    heatmapLayer = L.heatLayer(points, {
                        radius: 4,          // 点的基础半径（单位：像素）
                        blur: 2,            // 模糊程度（0 表示无光晕）
                        maxZoom: 18,        // 最大缩放级别后停止渲染
                        minOpacity: 0.4,    // 最小透明度（整体透明度）
                        gradient: {         // 颜色梯度配置
                            0.1: 'rgba(0, 0, 255, 0.9)',  // 低密度区域颜色
                            0.5: 'rgba(255, 255, 0, 0.6)',
                            1.0: 'rgba(255, 0, 0, 0.2)'   // 高密度区域颜色
                        }
                    }).addTo(map);

                    // 为热力图的 canvas 元素设置 willReadFrequently 属性
                    const canvas = heatmapLayer._canvas;
                    if (canvas) {
                        canvas.willReadFrequently = true;
                    }
                })
                .catch(error => console.error('Error:', error));
        }

        let debounceTimeout = null;

        // 监听地图移动事件
        map.on('moveend', function () {
            if (debounceTimeout) {
                clearTimeout(debounceTimeout);
            }

            debounceTimeout = setTimeout(() => {
                const bounds = map.getBounds();
                loadDataForBounds(bounds);
            }, 200); // 延迟 200 毫秒触发
        });

        // 初始化加载数据
        const initialBounds = map.getBounds();
        loadDataForBounds(initialBounds);

        // 添加坐标转换函数
        function wgs84ToGcj02(lat, lng) {
            const a = 6378245.0;
            const ee = 0.00669342162296594323;

            function transformLat(x, y) {
                let ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
                ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0;
                ret += (20.0 * Math.sin(y * Math.PI) + 40.0 * Math.sin(y / 3.0 * Math.PI)) * 2.0 / 3.0;
                ret += (160.0 * Math.sin(y / 12.0 * Math.PI) + 320 * Math.sin(y * Math.PI / 30.0)) * 2.0 / 3.0;
                return ret;
            }

            function transformLng(x, y) {
                let ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
                ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0;
                ret += (20.0 * Math.sin(x * Math.PI) + 40.0 * Math.sin(x / 3.0 * Math.PI)) * 2.0 / 3.0;
                ret += (150.0 * Math.sin(x / 12.0 * Math.PI) + 300.0 * Math.sin(x / 30.0 * Math.PI)) * 2.0 / 3.0;
                return ret;
            }

            const dLat = transformLat(lng - 105.0, lat - 35.0);
            const dLng = transformLng(lng - 105.0, lat - 35.0);
            const radLat = lat / 180.0 * Math.PI;
            const magic = Math.sin(radLat);
            const sqrtMagic = Math.sqrt(1 - ee * magic * magic);
            const dLatFinal = (dLat * 180.0) / ((a * (1 - ee)) / (sqrtMagic ** 3) * Math.PI);
            const dLngFinal = (dLng * 180.0) / (a / sqrtMagic * Math.cos(radLat) * Math.PI);
            return [lat + dLatFinal, lng + dLngFinal];
        }

        // 修改点击事件处理
        map.on('click', function (e) {
            const lat = e.latlng.lat;
            const lng = e.latlng.lng;

            let closestPoint = null;
            let minDistance = Infinity;
            currentPoints.forEach(p => {
                const distance = Math.sqrt(Math.pow(p.lat - lat, 2) + Math.pow(p.lng - lng, 2));
                if (distance < minDistance) {
                    minDistance = distance;
                    closestPoint = p;
                }
            });

            if (closestPoint) {
                const [gcjLat, gcjLng] = wgs84ToGcj02(closestPoint.lat, closestPoint.lng);
                fetch(`https://restapi.amap.com/v3/geocode/regeo?key=8194eb1949ecf804aad037366e838ef1&location=${gcjLng},${gcjLat}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === '1' && data.regeocode) {
                            const address = data.regeocode.formatted_address;
                            L.popup()
                                .setLatLng([closestPoint.lat, closestPoint.lng])
                                .setContent(`
                                    <b>文件路径:</b> ${closestPoint.path}<br>
                                    <b>拍摄时间:</b> ${closestPoint.timestamp}<br>
                                    <b>地址:</b> ${address}
                                `)
                                .openOn(map);
                        }
                    })
                    .catch(error => console.error('地址请求失败:', error));
            }
        });
    </script>
</body>
</html>
